# å•è°ƒæ ˆ

[toc]

## ç»å…¸ç”¨æ³•

### é—®é¢˜æè¿°
å•è°ƒæ ˆæœ€ç»å…¸çš„ç”¨æ³•æ˜¯è§£å†³å¦‚ä¸‹é—®é¢˜ï¼š
- æ¯ä¸ªä½ç½®éƒ½æ±‚ï¼š
    - å½“å‰ä½ç½®çš„**å·¦ä¾§**æ¯”å½“å‰ä½ç½®çš„æ•°å­—**å°**ï¼Œ**ä¸”è·ç¦»æœ€è¿‘çš„ä½ç½®**åœ¨å“ª
    - å½“å‰ä½ç½®çš„**å³ä¾§**æ¯”å½“å‰ä½ç½®çš„æ•°å­—**å°**ï¼Œ**ä¸”è·ç¦»æœ€è¿‘çš„ä½ç½®**åœ¨å“ª
- **æˆ–è€…**
- æ¯ä¸ªä½ç½®éƒ½æ±‚ï¼š
    - å½“å‰ä½ç½®çš„**å·¦ä¾§**æ¯”å½“å‰ä½ç½®çš„æ•°å­—**å¤§**ï¼Œ**ä¸”è·ç¦»æœ€è¿‘çš„ä½ç½®**åœ¨å“ª
    - å½“å‰ä½ç½®çš„**å³ä¾§**æ¯”å½“å‰ä½ç½®çš„æ•°å­—**å¤§**ï¼Œ**ä¸”è·ç¦»æœ€è¿‘çš„ä½ç½®**åœ¨å“ª

ç”¨å•è°ƒæ ˆçš„æ–¹å¼å¯ä»¥åšåˆ°ï¼šæ±‚è§£è¿‡ç¨‹ä¸­ï¼Œ**å•è°ƒæ ˆæ‰€æœ‰è°ƒæ•´çš„æ€»ä»£ä»·ä¸ºO(n)ï¼Œå•æ¬¡æ“ä½œçš„å‡æ‘Šä»£ä»·ä¸ºO(1)**

### æ¨¡æ¿ä»£ç 
**å…³é”®ï¼ä¸åŒé¢˜ç›®ä¸­ç›¸ç­‰å€¼å‡ºç°æ—¶çš„å¤„ç†ï¼ç”¨åç»­çš„ç›¸å…³é¢˜ç›®è¯´æ˜**
æµ‹è¯•é“¾æ¥ï¼šhttps://www.nowcoder.com/practice/2a2c00e7a88a498693568cef63a4b7bb
```c++
 #include<cstdio>
const int MAXN = 1000005;
int arr[MAXN];
int stack[MAXN];
int ans[MAXN][2];
int n, size;

void compute(){
    size = 0;   //æ ˆçš„å¤§å°
    int curIndex;
    for(int i = 0; i < n; i++){
        //å› ä¸ºè¦æ±‚çš„æ—¶è·ç¦»æœ€è¿‘ä¸”å°çš„å€¼ï¼Œæ‰€ä»¥ç»´æŠ¤çš„æ˜¯ä¸€ä¸ªæ ˆé¡¶åˆ°æ ˆåº•ä¸¥æ ¼å¤§åˆ°å°çš„å•è°ƒæ ˆ
        //å¦‚æœæ ˆé¡¶å…ƒç´ å¤§äºç­‰äºå½“å‰å…ƒç´ ï¼Œæ ˆé¡¶å…ƒç´ å‡ºæ¥å¹¶ç»“ç®—
        while(size > 0 && arr[i] <= arr[stack[size - 1]]){ 
            curIndex = stack[--size];
            ans[curIndex][0] = size > 0 ? stack[size - 1] : -1;
            ans[curIndex][1] = i;
        }
        stack[size++] = i;  //æ­¤æ—¶æ ˆä¸­çš„å…ƒç´ è¦ä¹ˆä¸ºç©ºï¼Œè¦ä¹ˆéƒ½æ¯”å½“å‰ä½ç½®çš„æ•°å°ï¼Œç›´æ¥å‹æ­»
    }
    //æ ˆä¸ä¸ºç©ºï¼Œè¯´æ˜å³è¾¹æ²¡æœ‰æ¯”å®ƒå°çš„ï¼Œå‡ºæ¥å¹¶ç»“ç®—
    while(size > 0){
        curIndex = stack[--size];
        ans[curIndex][0] = size > 0 ? stack[size - 1] : -1;
        ans[curIndex][1] = -1;    
    }
    //è¡¥ç®—ä¹‹å‰å› ä¸ºç›¸ç­‰å‡ºæ¥çš„æ•°å­—
    //å› ä¸ºæ ˆä¸­çš„ä¸‹æ ‡å¯¹åº”çš„æ•°å­—æ˜¯ä¸¥æ ¼å•è°ƒçš„ï¼Œæ‰€ä»¥å·¦è¾¹ç­”æ¡ˆæ²¡æœ‰é”™
    //å³è¾¹å› ä¸ºç›¸ç­‰ä¹Ÿä¼šå‡ºæ ˆï¼Œä¼šå‡ºé”™ï¼Œä¸è®©ä»–å‡ºæ ˆçš„å“ªä¸ªæ•°å­—çš„å³è¾¹ä¿æŒä¸€è‡´å°±è¡Œäº†
    //ä»å³å¾€å·¦æ˜¯å› ä¸ºæœ€å³è¾¹çš„é‚£ä¸ªç­”æ¡ˆæ˜¯å¯¹çš„
    //æœ€åä¸€ä¸ªæ•°å³è¾¹æ²¡æ•°äº†ï¼Œä¸ç”¨ç®¡
    for(int i = n - 2; i >= 0; i--){
        //iä½ç½®çš„æ•°å’Œè®©å®ƒå‡ºæ ˆçš„ans[i][1]ä½ç½®çš„æ•°ç«Ÿç„¶ç›¸ç­‰ï¼Œä¸å¯¹åŠ²äº†bro
        if(ans[i][1] != -1 && arr[ans[i][1]] == arr[i]){
            ans[i][1] = ans[ans[i][1]][1];
        }
    }
}

int main() {
    scanf("%d", &n);
    for(int i = 0; i < n; i++)
        scanf("%d", arr + i);
    compute();
    for(int i = 0; i < n; i++)
        printf("%d %d\n", ans[i][0], ans[i][1]);
    return 0;
}
```

### ç›¸å…³é¢˜ç›®
#### é¢˜ç›®1ï¼šæ¯æ—¥æ¸©åº¦
æµ‹è¯•é“¾æ¥ï¼šhttps://leetcode.cn/problems/daily-temperatures/
```c++
class Solution {
private:
    static const int MAXN = 100005;
    static int stack[MAXN];
    int size;
public:
    vector<int> dailyTemperatures(vector<int>& temperatures) {
        size = 0;
        vector<int> ans(temperatures.size());
        for(int i = 0; i < temperatures.size(); i++){
            //å½“å‰æ°”æ¸©é«˜äºæ ˆé¡¶é‚£å¤©çš„æ°”æ¸©ï¼Œå¯ä»¥ç»“ç®—äº†
            while(size > 0 && temperatures[i] > temperatures[stack[size - 1]]){
                //å‡ºæ ˆå¹¶ç»“ç®—æ ˆé¡¶é‚£å¤©è·ç¦»åç»­æ›´é«˜æ¸©å‡ºç°çš„å¤©æ•°
                size--;
                ans[stack[size]] = i - stack[size]; 
            }
            stack[size++] = i;
        }
        //æ ˆä¸­å…ƒç´ æœ¬æ¥å…¨ä¸º0ï¼Œæ‰€ä»¥ä¸‹é¢çš„ä»£ç å¯ä»¥æ³¨é‡Šæ‰
        //åç»­æ²¡æœ‰æ›´é«˜ï¼Œè¿˜åœ¨æ ˆä¸­çš„å‡ºæ ˆå¹¶æ ‡ä¸º0è¡¨ç¤ºåç»­æ²¡æœ‰æ›´é«˜æ¸©å¤©æ°”
        // while(size > 0){
        //     size--;
        //     ans[stack[size]] = 0;
        // }
        return ans;
    }
};

int Solution::stack[MAXN] = {0};
```

#### é¢˜ç›®2ï¼šå­æ•°ç»„çš„æœ€å°å€¼ä¹‹å’Œ
æµ‹è¯•é“¾æ¥ï¼šhttps://leetcode.cn/problems/sum-of-subarray-minimums/
```c++
class Solution {
private:
    static const int mod = 1000000007;
    static const int MAXN = 30005;
    static int stack[MAXN];
    int size;
public:
    //è€ƒè™‘ä»¥æ¯ä¸ªiä½ç½®å€¼ä¸ºæœ€å°å€¼çš„å­æ•°ç»„
    //å·¦è¾¹lä½ç½®ç¬¬ä¸€ä¸ªæ¯”iä½ç½®å°çš„æ˜¯å·¦è¾¹ç•Œï¼Œå³è¾¹rä½ç½®ç¬¬ä¸€ä¸ªæ¯”iå°çš„æ˜¯å³è¾¹ç•Œï¼Œç»å…¸å•è°ƒæ ˆé—®é¢˜
    //å­æ•°ç»„å¼€å¤´å¯èƒ½æ€§[l+1, i]ï¼Œå­æ•°ç»„ç»“å°¾å¯èƒ½æ€§[i, r - 1]
    //å­æ•°ç»„ä¸ªæ•° = å¼€å¤´å¯èƒ½æ€§ * ç»“å°¾å¯èƒ½æ€§ = (i - l) * (r - i)
    //å­æ•°ç»„å’Œ = å­æ•°ç»„ä¸ªæ•° * iä½ç½®çš„æ•° = (i - l) * (r - i) * arr[i]
    int sumSubarrayMins(vector<int>& arr) {
        int n = arr.size();
        size = 0;
        long long sum = 0;
        for(int i = 0; i < n; i++){
            //å°çš„å‡ºç°äº†ï¼Œå¯ä»¥ç»“ç®—äº†
            //ç›¸ç­‰çš„æœ€åä¸€ä¸ªä¼šç®—å¯¹çš„ï¼Œåˆ«æ€•
            //ç­‰å·å»æ‰ï¼Œå°±æ˜¯ç¬¬ä¸€ä¸ªå‡ºæ¥çš„æ—¶å€™ä¼šç»“ç®—
            while(size > 0 && arr[i] <= arr[stack[size - 1]]){
                size--;
                int l = size > 0 ? stack[size - 1] : -1;
                sum = (sum + (long long)(stack[size] - l) * (i - stack[size]) * arr[stack[size]]) % mod;
            }
            stack[size++] = i;
        }
        while(size > 0){
            size--;
            int l = size > 0 ? stack[size - 1] : -1;
            sum = (sum + (long long)(stack[size] - l) * (n - stack[size]) * arr[stack[size]]) % mod;
        }
        return sum;
    }
};

int Solution::stack[MAXN] = {0};
```

#### é¢˜ç›®3ï¼šæŸ±çŠ¶å›¾ä¸­æœ€å¤§çš„çŸ©å½¢
æµ‹è¯•é“¾æ¥ï¼šhttps://leetcode.cn/problems/largest-rectangle-in-histogram
```c++
class Solution {
private:
    static const int MAXN = 100005;
    static int stack[MAXN];
    int size;
public:
    //å‡è®¾curæ˜¯å½“å‰æŸ±å­ï¼Œè€ƒè™‘ä»¥å½“å‰æŸ±å­ä½œä¸ºé«˜åº¦çš„çŸ©å½¢
    //æƒ³ä»¥å½“å‰æŸ±å­é«˜åº¦ä½œä¸ºçŸ©å½¢çš„é«˜åº¦ï¼Œéœ€è¦å·¦å³æŸ±å­éƒ½å¤§äºç­‰äºå½“å‰æŸ±å­é«˜åº¦æ‰è¡Œ
    //æ‰€ä»¥éœ€è¦æ‰¾åˆ°çš„å°±æ˜¯å·¦å³ç¦»å½“å‰æŸ±å­æœ€è¿‘çš„æ¯”å½“å‰æŸ±å­çŸ®çš„æŸ±å­ï¼Œç»å…¸å•è°ƒæ ˆé—®é¢˜
    //å‡è®¾å·¦è¾¹æœ€è¿‘ä¸”æ¯”å½“å‰æŸ±å­çŸ®çš„æŸ±å­ä½ç½®ä¸ºlï¼Œå³è¾¹ä¸ºr
    //åº•è¾¹æŸ±å­å°±æ˜¯[l+1, r-1]èŒƒå›´ä¸Šçš„æŸ±å­
    //é•¿åº¦ä¸ºr - l - 1 -> é¢ç§¯ä¸º(r - l - 1) * heights[cur]
    int largestRectangleArea(vector<int>& heights) {
        int n = heights.size();
        int size = 0;
        int maxArea = 0;
        for(int i = 0; i < n; i++){
            //å½“å‰ä½ç½®æŸ±å­æ¯”æ ˆé¡¶ä½ç½®æŸ±å­çŸ®ï¼Œå¯ä»¥å‡ºæ¥ç»“ç®—äº†
            //ç›¸ç­‰æ—¶å¤„ç†ä¸ä¸Šä¸€é¢˜ç±»ä¼¼
            while(size > 0 && heights[i] <= heights[stack[size - 1]]){
                size--;
                int l = size > 0 ? stack[size - 1] : -1;
                maxArea = max(maxArea, (i - l - 1) * heights[stack[size]]);
            }
            stack[size++] = i;
        }
        while(size > 0){
            size--;
            int l = size > 0 ? stack[size - 1] : -1;
            maxArea = max(maxArea, (n - l - 1) * heights[stack[size]]);
        }
        return maxArea;
    }
};

int Solution::stack[MAXN] = {0};
```

#### é¢˜ç›®4ï¼šæœ€å¤§çŸ©å½¢
æµ‹è¯•é“¾æ¥ï¼šhttps://leetcode.cn/problems/maximal-rectangle/
```c++
class Solution {
private:
    static const int MAXN = 205;
    static int heights[MAXN];
    static int stack[MAXN];
    int size;
public:
    //colså°±æ˜¯æŸ±å­çš„ä¸ªæ•°
    int largestRectangleArea(int cols){
        size = 0;
        int maxArea = 0;
        for(int i = 0; i < cols; i++){
            while(size > 0 && heights[i] <= heights[stack[size - 1]]){
                size--;
                int l = size > 0 ? stack[size - 1] : -1;
                maxArea = max(maxArea, (i - l - 1) * heights[stack[size]]);
            }
            stack[size++] = i;
        }
        while(size > 0){
            size--;
            int l = size > 0 ? stack[size - 1] : -1;
            maxArea = max(maxArea, (cols - l - 1) * heights[stack[size]]);
        }
        return maxArea;
    }

    int maximalRectangle(vector<vector<char>>& matrix) {
        int rows = matrix.size();
        int cols = matrix[0].size();
        int maxArea = 0;
        for(int row = 0; row < rows; row++){
            //è®¡ç®—ä»¥rowè¡Œä½œä¸ºåº•çš„æ¯ä¸ªcolåˆ—çš„æŸ±å­é«˜åº¦
            for(int col = 0; col < cols; col++)
                heights[col] = matrix[row][col] == '0' ? 0 : heights[col] + 1;
            maxArea = max(maxArea, largestRectangleArea(cols));
        }
        clear(cols);
        return maxArea;
    }

    void clear(int cols){
        for(int i = 0; i < cols; i++)
            heights[i] = 0;
    }
};

int Solution::heights[MAXN] = {0};
int Solution::stack[MAXN] = {0};
```

## è¿›é˜¶ç”¨æ³•

### introduction

é™¤äº†å•è°ƒæ ˆæœ€ç»å…¸çš„ç”¨æ³•ä¹‹å¤–ï¼Œåœ¨å¾ˆå¤šé—®é¢˜é‡Œå•è°ƒæ ˆè¿˜å¯ä»¥**ç»´æŒæ±‚è§£ç­”æ¡ˆçš„å¯èƒ½æ€§**
1. å•è°ƒæ ˆé‡Œçš„æ‰€æœ‰å¯¹è±¡æŒ‰ç…§**è§„å®šå¥½çš„å•è°ƒæ€§ç»„ç»‡**
2. å½“æŸä¸ªå¯¹è±¡è¿›å…¥å•è°ƒæ ˆæ—¶ï¼Œä¼šä»**æ ˆé¡¶å¼€å§‹**ä¾æ¬¡æ·˜æ±°å•è°ƒæ ˆé‡Œ**å¯¹åç»­æ±‚è§£ç­”æ¡ˆæ²¡æœ‰å¸®åŠ©**çš„å¯¹è±¡
3. æ¯ä¸ªå¯¹è±¡ä»æ ˆé¡¶å¼¹å‡ºæ—¶**ç»“ç®—å½“å‰å¯¹è±¡å‚ä¸çš„ç­”æ¡ˆ**ï¼Œéšåè¿™ä¸ªå¯¹è±¡**ä¸å†å‚ä¸åç»­æ±‚è§£ç­”æ¡ˆçš„è¿‡ç¨‹**
4. å…¶å®æ—¶**å…ˆæœ‰å¯¹é¢˜ç›®çš„åˆ†æï¼**è¿›è€Œ**å‘ç°å•è°ƒæ€§**ï¼Œç„¶ååˆ©ç”¨**å•è°ƒæ ˆçš„ç‰¹å¾**å»å®ç°

### ç›¸å…³ä¾‹é¢˜

#### é¢˜ç›®1ï¼šæœ€å¤§å®½åº¦å¡
æµ‹è¯•é“¾æ¥ï¼šhttps://leetcode.cn/problems/maximum-width-ramp/
```c++
class Solution {
private:
    static const int MAXN = 50005;
    static int stack[MAXN];
    int size;
public:
    int maxWidthRamp(vector<int>& heights) {
        int n = heights.size();
        size = 0;
        for(int i = 0; i < n; i++){
            //å¯èƒ½æœ‰æ›´å¥½çš„ç­”æ¡ˆæ‰è¿›å…¥æ ˆ
            //æ ˆæ˜¯ä¸¥æ ¼å°å‹å¤§çš„
            //åªæœ‰æœ¬æ¬¡é«˜åº¦æ›´ä½ï¼Œæ‰æœ‰å¯èƒ½äº§ç”Ÿæ›´å®½çš„å¡
            if(size == 0 || heights[i] < heights[stack[size - 1]])
                stack[size++] = i;
        }
        //ä»å³å¾€å·¦éå†ç»“ç®—ç­”æ¡ˆï¼Œéƒ½æ˜¯æ‰¾åˆ°æœ€è¿œçš„æ¯”è‡ªå·±é«˜çš„
        int ans = 0;
        for(int i = heights.size() - 1; i >= 0; i--){
            while(size > 0 && heights[i] >= heights[stack[size - 1]]){
                --size;
                ans = max(ans, i - stack[size]);
            }
        }
        return ans;
    }
};
int Solution::stack[MAXN] = {0};
```

#### é¢˜ç›®2ï¼šå»é™¤é‡å¤å­—æ¯ä¿è¯å‰©ä½™å­—ç¬¦ä¸²çš„å­—å…¸åºæœ€å°
æµ‹è¯•é“¾æ¥ï¼šhttps://leetcode.cn/problems/remove-duplicate-letters/
```c++
class Solution {
private:
    static const int MAXN = 26; // æ ˆçš„å¤§å°ä¸å¯èƒ½è¶…è¿‡å­—æ¯çš„ä¸ªæ•°
    static char stack[MAXN];
    static bool chEnteredMap[MAXN];
    static int chCountMap[MAXN];
    int size;

public:
    string removeDuplicateLetters(string s) {
        size = 0;
        // ç»Ÿè®¡æ¯ä¸ªå­—ç¬¦çš„è¯é¢‘
        for (char ch : s)
            chCountMap[ch - 'a']++;

        // éå†æ¯ä¸ªå­—ç¬¦ï¼Œçœ‹è¯¥å­—ç¬¦èƒ½å¦è¿›æ ˆ
        // æ ˆå°½å¯èƒ½å¤§å‹å°ï¼Œåº•éƒ¨ä»£è¡¨å»é‡å­—ç¬¦ä¸²çš„å¤´éƒ¨
        for (char ch : s) {
            //è¿™ä¸ªå­—ç¬¦ä¸åœ¨æ ˆä¸­æ‰éœ€è¦æ“ä½œï¼Œåœ¨æ ˆä¸­å°±ä¸ç”¨ç®¡äº†ï¼Œå› ä¸ºä¸èƒ½é‡å¤
            if (!chEnteredMap[ch - 'a']) {
                // å½“å‰å­—ç¬¦å°äºæ ˆé¡¶å­—ç¬¦ä¸”åé¢è¿˜æœ‰æ ˆé¡¶å­—ç¬¦
                // é‚£æ ˆé¡¶å­—ç¬¦ç›´æ¥å¼¹å‡ºï¼Œæ”¾åœ¨åé¢å­—å…¸åºæ›´å°
                while (size > 0 && ch < stack[size - 1] &&
                       chCountMap[stack[size - 1] - 'a'] > 0) {
                    size--;
                    chEnteredMap[stack[size] - 'a'] = false;
                }
                stack[size++] = ch;
                chEnteredMap[ch - 'a'] = true;
            }
            chCountMap[ch - 'a']--;
        }
        clear();
        return string(stack, stack + size);
    }

    void clear(){
        for(int i = 0; i < MAXN; i++){
            chEnteredMap[i] = false;
            chCountMap[i] = 0;
        }
    }
};

char Solution::stack[MAXN];
bool Solution::chEnteredMap[MAXN] = {false};
int Solution::chCountMap[MAXN] = {0};
```

#### é¢˜ç›®3ï¼šå¤§é±¼åƒå°é±¼é—®é¢˜
æµ‹è¯•é“¾æ¥ï¼šhttps://www.nowcoder.com/practice/77199defc4b74b24b8ebf6244e1793de
```c++
#include<cstdio>
#include<algorithm>
using std::max;
const int MAXN = 100005;
int A[MAXN];
int stack[MAXN][2];
int N, size;

int turns(){
    int ans = 0;
    for(int i = N - 1; i >= 0; i--){
        int round = 0;
        //å½“å‰ğŸŸèƒ½å¤Ÿåƒæ‰åé¢çš„ğŸŸ(æ ˆé‡Œçš„ğŸŸä¸¥æ ¼å°å‹å¤§)
        //å½“å‰ğŸŸä¼šåƒæ‰æ ˆé¡¶çš„ğŸŸ
        //åƒæ‰æ ˆé¡¶ğŸŸçš„è½®æ•°å’Œæ ˆé¡¶ğŸŸåƒæ‰åé¢ğŸŸçš„è½®æ•°è¦å–æœ€å¤§å€¼
        while(size > 0 && A[i] > A[stack[size - 1][0]]){
            size--;
            round = max(round + 1, stack[size][1]);
        }
        stack[size][0] = i;
        stack[size++][1] = round;
        ans = max(ans, round);
    }
    return ans;
}

int main() {
    scanf("%d", &N);
    for(int i = 0; i < N; i++)
        scanf("%d", A + i);
    printf("%d\n", turns());
    return 0;
}
```

#### é¢˜ç›®4ï¼šç»Ÿè®¡å…¨1å­çŸ©é˜µçš„æ•°é‡
æµ‹è¯•é“¾æ¥ï¼šhttps://leetcode.cn/problems/count-submatrices-with-all-ones/
```c++
class Solution {
private:
    static const int MAXN = 155;
    static int heights[MAXN];
    static int stack[MAXN];
    int size;
public:
    //è®¡ç®—ä¸€ä¸ªç›´æ–¹å›¾ä¸­çŸ©å½¢çš„ä¸ªæ•°
    //ä¸ºäº†ä¸é‡å¤ç®—ï¼Œæ¯ä¸ªä½ç½®åªç®—çªå‡ºçš„ä½ç½®
    int countFromBottom(int n){
        size = 0;
        int ans = 0;
        for(int i = 0, cur; i < n; i++){
            while(size > 0 && heights[i] <= heights[stack[size - 1]]){
                cur = stack[--size];
                //é«˜åº¦ä¸¥æ ¼å°æ‰ç®—ï¼ŒåŒæ ·é«˜åº¦åŒºé—´ç®—ä¸€æ¬¡å°±è¡Œäº†
                if(heights[i] < heights[cur]){
                    int l = size > 0 ? stack[size - 1] : -1;
                    int lowerBound = max(l == -1 ? 0 : heights[l], heights[i]);
                    //æ³¨æ„ï¼šå·¦å³æ˜¯åˆ°ä¸äº†çš„ï¼Œ[l + 1, i - 1]
                    //é«˜åº¦åŒºé—´[lowerBound + 1, heights[cur]]ä¸­ï¼Œä»»æ„ä¸ºhçš„çŸ©å½¢ä¸ªæ•°å¦‚ä¸‹ï¼š
                    //[l + 1, l + 1] ... [l + 1, i - 1] [l + 2, l + 2] ... ...[i - 1, i - 1]
                    //(i - l - 1) + (i - l - 2) + ... + 1
                    //ç­‰å·®æ•°åˆ—æ±‚å’Œï¼š(é¦–é¡¹ + å°¾é¡¹) * é¡¹æ•° / 2 = (i - l -1 + 1) * (i - l - 1) / 2 
                    ans += (heights[cur] - lowerBound) * (i - l) * (i - l - 1) / 2; 
                }
            }
            stack[size++] = i;
        }
        while(size > 0){
            --size;
            int l = size > 0 ? stack[size - 1] : -1;
            int lowerBound = l == -1 ? 0 : heights[l];
            ans += (heights[stack[size]] - lowerBound) * (n - l) * (n - l - 1) / 2;
        }
        return ans;
    }

    int numSubmat(vector<vector<int>>& mat) {
        int m = mat.size();
        int n = mat[0].size();
        //è®¡ç®—ä»¥æ¯ä¸€è¡Œä¸ºåº•çš„çŸ©å½¢ä¸ªæ•°
        int ans = 0;
        for(int i = 0; i < m; i++){
            for(int j = 0; j < n; j++)
                heights[j] = mat[i][j] ? heights[j] + 1 : 0;
            ans += countFromBottom(n);
        }
        clear(n);   //æ¸…æ¥šé«˜åº¦æ•°ç»„ä¸­çš„è„æ•°æ®
        return ans;
    }

    void clear(int n){
        for(int i = 0; i < n; i++)
            heights[i] = 0;
    }
};

int Solution::stack[MAXN];
int Solution::heights[MAXN];
```