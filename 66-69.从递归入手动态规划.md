# 前情提要
动态规划的大致过程：
想出设计优良的递归尝试（**方法、经验、固定套路很多**），**有关尝试展开顺序的说明**
1. 记忆化搜索（从顶到底的动态规划），**如果每个状态的计算枚举代价很低，往往到这里就可以了**
2. 严格位置依赖的动态规划（从底到顶的动态规划），更多是为了下面说的**进一步优化枚举做的准备**
3. 进一步优化空间（**空间压缩**），一维、二维、多维动态规划都存在这种优化
4. **进一步优化枚举也就是优化时间**

解决一个问题，可能有很多尝试方法
众多的尝试方法中，可能若干的尝试方法有重复调用的情况，可以转化成动态规划
若干各可以转化成动态规划的方法中，又可能优劣之分
判定哪个是最优的动态规划方法，**依据来自题目具体参数的数据量**
最优的动态规划方法实现后，**后续又有一整套的优化技巧**

动态规划表的大小：**每个可变参数的可能性数量相乘**

动态规划方法的时间复杂度：**动态规划表的大小 * 每个格子的枚举代价**

能改成动态规划的递归，统一特征：**决定返回值的可变参数类型往往都比较简单，一般不会比int类型更复杂。**

从这个角度，可以解释**带路径的递归（可变参数类型复杂），不适合或者说没有必要改成动态规划**
- 案例链接：https://leetcode.cn/problems/word-search/
- 该案例就是i和j**无法完全决定返回值**，board的状态对返回值也有影响
```c++
class Solution {
private:
    static constexpr int move[5] = {-1, 0, 1, 0, -1};
public:
    bool exist(vector<vector<char>>& board, string word) {
        int m = board.size();
        int n = board[0].size();
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (process(board, i, j, word, 0))
                    return true;
            }
        }
        return false;
    }

    //剪枝：字符串指导的剪枝 
    bool process(vector<vector<char>>& board, int i, int j, const string& word,
                 int cur) {
        if (cur == word.size())
            return true;
        // 越界或者碰到使用过的字符
        if (i < 0 || i >= board.size() || j < 0 || j >= board[i].size() || board[i][j] != word[cur])
            return false;
        // 正常情况
        char tmp = board[i][j];
        board[i][j] = 0;

        // 上下左右看一看
        for(int k = 0; k < 4; k++){
            if (process(board, i + move[k], j + move[k + 1], word, cur + 1))
                return true;
        }

        board[i][j] = tmp; //失败了记得恢复现场
        return false;
    }
};
```

一定要**写出可变参数类型简单（不比int类型更复杂）**，并且**可以完全决定返回值的递归**，
保证做到**这些可变参数可以完全代表之前决策过程对后续过程的影响！**再去改动态规划！

不管几维动态规划
经常**从递归的定义出发，避免后续进行很多边界讨论**，比如说下标 < 0做边界条件 可以变成 长度 == 0做边界条件
这需要一定的经验来预知

# 从递归入手一维动态规划

尝试函数有1个可变参数**可以完全决定返回值**，进而可以改出一维动态规划表的实现

## 简介

任何动态规划问题都一定对应着一个有重复调用行为的递归
所以任何动态规划的题目都一定可以从递归入手，逐渐改出动态规划的实现

**尝试策略**就是**转移方程**，完全一回事！
**推荐从尝试入手，因为代码好写，并且一旦发现尝试错误，重新想别的递归代价轻！**

## 相关例题

### 题目1：斐波那契数
测试链接：https://leetcode.cn/problems/fibonacci-number/
1. 递归尝试
```c++
class Solution {
public:
    int fib(int n) {
        if(n == 0)
            return 0;
        else if(n == 1)
            return 1;
        else
            return fib(n - 1)  + fib(n - 2);
    }
};
```
2. 记忆化搜索（顶到底）
```c++
class Solution {
public:
    int fib(int n) {
        vector<int> dp(n + 1, -1);
        return f(n, dp);
    }
    int f(int n, vector<int> &dp){
        if(dp[n] != -1)
            return dp[n];
        if(n == 0)
            return 0;
        else if(n == 1)
            return 1;
        else{
            dp[n] = f(n - 1, dp) + f(n - 2, dp);
            return dp[n];
        }
    }
};
```
3. 严格位置依赖的动态规划（底到顶）
```c++
class Solution {
public:
    int fib(int n) {
        if(n == 0)
            return 0;
        if(n == 1)
            return 1;
        vector<int> dp(n + 1);
        dp[1] = 1;
        for(int i = 2; i <= n; i++)
            dp[i] = dp[i - 1] + dp[i - 2];
        return dp[n];
    }
}; 
```
4. 空间压缩
```c++
class Solution {
public:
    int fib(int n) {
        if(n == 0)
            return 0;
        if(n == 1)
            return 1;
        int lastLast = 0;
        int last = 1;
        for(int i = 2, cur; i <= n; i++){
            cur = lastLast + last;
            lastLast = last;
            last = cur;
        }
        return last;
    }
}; 
```

### 题目2：最低票价
测试链接：https://leetcode.cn/problems/minimum-cost-for-tickets/
1. 递归尝试（过不了，复杂度太高了）
```c++
class Solution {
private:
    static constexpr int durations[3] = {1, 7, 30};
public:
    int mincostTickets(vector<int>& days, vector<int>& costs) {
        return f(days, costs, 0);
    }
    //完成[i...end]位置每一天旅行需要最低消费
    int f(vector<int>& days, vector<int>& costs, int i){
        //区间长度为0
        if(i == days.size())
            return 0;
        int minCost = INT_MAX;
        for(int k = 0, j = i; k < 3; k++){
            //使用第k种销售方式能完成的旅行就跳过，到最后或者第一个无法旅行的那一天
            while(j < days.size() && days[j] < days[i] + durations[k])
                j++;
            minCost = min(minCost, costs[k] + f(days, costs, j));
        }
        return minCost;
    }
};
```
2. 记忆化搜索（顶到底）
```c++
class Solution {
private:
    static constexpr int durations[3] = {1, 7, 30};
public:
    int mincostTickets(vector<int>& days, vector<int>& costs) {
        vector<int> dp(days.size() + 1, -1);
        return f(days, costs, 0, dp);
    }
    //完成[i...end]位置每一天旅行需要最低消费
    int f(vector<int>& days, vector<int>& costs, int i, vector<int> &dp){
        if(dp[i] != -1)
            return dp[i];
        //区间长度为0
        if(i == days.size())
            return 0;
        int minCost = INT_MAX;
        for(int k = 0, j = i; k < 3; k++){
            while(j < days.size() && days[j] < days[i] + durations[k])
                j++;
            minCost = min(minCost, costs[k] + f(days, costs, j, dp));
        }
        dp[i] = minCost;
        return minCost;
    }
};
```
3. 严格位置依赖的动态规划（底到顶）
```c++
class Solution {
private:
    static constexpr int durations[3] = {1, 7, 30};
public:
    int mincostTickets(vector<int>& days, vector<int>& costs) {
        int n = days.size();
        vector<int> dp(n + 1);
        dp[n] = 0;
        for(int i = n - 1; i >= 0; i--){
            int minCost= INT_MAX;
            for(int k = 0, j = i; k < 3; k++){
                while(j < days.size() && days[j] < days[i] + durations[k])
                    j++;
                minCost = min(minCost, costs[k] + dp[j]);
            }
            dp[i] = minCost;
        }
        return dp[0];
    }
};
```

### 题目3：解码方法
测试链接：https://leetcode.cn/problems/decode-ways/
1. 递归尝试
```c++
class Solution {
public:
    int numDecodings(string s) { return f(s, 0); }
    //[i...end]解码方法的总数
    int f(const string& s, int i) {
        //可以理解为空串只有一种解码方法
        if (i == s.size())
            return 1;
        int num;
        if (s[i] == '0') //单独的0无法解码
            num = 0;
        else {
            num = f(s, i + 1);  //用1个位置解码
            if (i + 1 < s.size() && (s[i] - '0') * 10 + s[i + 1] - '0' <= 26) 
                num += f(s, i + 2); //用两个位置解码
        }
        return num;
    }
};
```
2. 记忆化搜索（顶到底）
```c++
class Solution {
public:
    int numDecodings(string s) {
        vector<int> dp(s.size(), -1);
        return f(s, 0, dp); 
    }
    //[i...end]解码方法的总数
    int f(const string& s, int i, vector<int> &dp) {
        //可以理解为空串只有一种解码方法
        if (i == s.size())
            return 1;
        //之前算过了，直接返回计算结果
        if(dp[i] != -1)
            return dp[i];
        int num;
        if (s[i] == '0') //单独的0无法解码
            num = 0;
        else {
            num = f(s, i + 1, dp);  //用1个位置解码
            if (i + 1 < s.size() && (s[i] - '0') * 10 + s[i + 1] - '0' <= 26) 
                num += f(s, i + 2, dp); //用两个位置解码
        }
        dp[i] = num; //保存计算结果
        return num;
    }
};
```
3. 严格位置依赖的动态规划（底到顶）
```c++
class Solution {
public:
    int numDecodings(string s) {
        int n = s.size();
        vector<int> dp(n + 1, -1);
        dp[n] = 1;
        for(int i = n - 1; i >= 0; i--){
            int num;
            if (s[i] == '0') //单独的0无法解码
                num = 0;
            else {
                num = dp[i + 1];  //用1个位置解码
                if (i + 1 < s.size() && (s[i] - '0') * 10 + s[i + 1] - '0' <= 26) 
                    num += dp[i + 2]; //用两个位置解码
            }
            dp[i] = num; //保存计算结果
        }
        return dp[0]; 
    }
};
```
4. 空间压缩
```c++
class Solution {
public:
    int numDecodings(string s) {
        int next = 1;
        int nextNext = 0;   //开始为0表示不存在
        for(int i = s.size() - 1, num; i >= 0; i--){
            if (s[i] == '0') //单独的0无法解码
                num = 0;
            else {
                num = next;  //用1个位置解码
                if (i + 1 < s.size() && (s[i] - '0') * 10 + s[i + 1] - '0' <= 26) 
                    num += nextNext; //用两个位置解码
            }
            nextNext = next;
            next = num;
        }
        return next; 
    }
};
```

### 题目4：解码方法Ⅱ
测试链接：https://leetcode.cn/problems/decode-ways-ii/
1. 递归尝试
```c++
class Solution {
private:
    static const int mod = 1000000007;
public:
    int numDecodings(string s) {
        return f(s, 0);
    }
    //子串s[i...end]的解码方法数
    long long f(const string &s, int i){
        //可以理解为空串只有一种解码方法
        if(i == s.size())
            return 1;
        long long num;
        if(s[i] == '0')
            num = 0;
        else{
            num = (s[i] == '*' ? 9 : 1) * f(s, i + 1);  //一个位置解码，*可以表示1 - 9
            if(i + 1 < s.size()){   //可以进行两个位置解码
                if(s[i] != '*'){
                    if(s[i + 1] != '*'){    //两个位置都不是*
                        if((s[i] - '0') * 10 + s[i + 1] - '0' <= 26)
                            num += f(s, i + 2);
                    }
                    else{   //i位置不是*，i + 1位置是*
                        if(s[i] == '1') //11 12 ... 19
                            num += 9 * f(s, i + 2); 
                        else if(s[i] == '2')    //21 22 ... 26
                            num += 6 * f(s, i + 2);
                    }
                }
                else{
                    if(s[i + 1] != '*') //i位置是*，i + 1位置不是*
                        num += (s[i + 1] <= '6' ? 2 : 1) * f(s, i + 2);
                    else//两个位置都是*，11 12 ... 19 21 22 ... 26
                        num += 15 * f(s, i + 2);
                }
            }
        }            
        return num % mod;
    }
};
```
2. 记忆化搜索（顶到底）
```c++
class Solution {
private:
    static const long long mod = 1000000007;
public:
    int numDecodings(string s) {
        vector<long long> dp(s.size(), -1);
        return f(s, 0, dp);
    }
    //子串s[i...end]的解码方法数
    long long f(const string &s, int i, vector<long long> dp){
        //可以理解为空串只有一种解码方法
        if(i == s.size())
            return 1;
        if(dp[i] != -1)
            return dp[i];
        long long num;
        if(s[i] == '0')
            num = 0;
        else{
            num = (s[i] == '*' ? 9 : 1) * f(s, i + 1, dp);  //一个位置解码，*可以表示1 - 9
            if(i + 1 < s.size()){   //可以进行两个位置解码
                if(s[i] != '*'){
                    if(s[i + 1] != '*'){    //两个位置都不是*
                        if((s[i] - '0') * 10 + s[i + 1] - '0' <= 26)
                            num += f(s, i + 2, dp);
                    }
                    else{   //i位置不是*，i + 1位置是*
                        if(s[i] == '1') //11 12 ... 19
                            num += 9 * f(s, i + 2, dp); 
                        else if(s[i] == '2')    //21 22 ... 26
                            num += 6 * f(s, i + 2, dp);
                    }
                }
                else{
                    if(s[i + 1] != '*') //i位置是*，i + 1位置不是*
                        num += (s[i + 1] <= '6' ? 2 : 1) * f(s, i + 2, dp);
                    else//两个位置都是*，11 12 ... 19 21 22 ... 26
                        num += 15 * f(s, i + 2, dp);
                }
            }
        }
        num %= mod;
        dp[i] = num;      
        return num;
    }
};
```
3. 严格位置依赖的动态规划（底到顶）
```c++
class Solution {
private:
    static const long long mod = 1000000007;
public:
    int numDecodings(string s) {
        int n = s.size();
        vector<long long> dp(n + 1, -1);
        dp[n] = 1;
        for(int i = n - 1; i >= 0; i--){
            long long num;
            if(s[i] == '0')
                num = 0;
            else{
                num = (s[i] == '*' ? 9 : 1) * dp[i + 1];  //一个位置解码，*可以表示1 - 9
                if(i + 1 < s.size()){   //可以进行两个位置解码
                    if(s[i] != '*'){
                        if(s[i + 1] != '*'){    //两个位置都不是*
                            if((s[i] - '0') * 10 + s[i + 1] - '0' <= 26)
                                num += dp[i + 2];
                        }
                        else{   //i位置不是*，i + 1位置是*
                            if(s[i] == '1') //11 12 ... 19
                                num += 9 * dp[i + 2]; 
                            else if(s[i] == '2')    //21 22 ... 26
                                num += 6 * dp[i + 2];
                        }
                    }
                    else{
                        if(s[i + 1] != '*') //i位置是*，i + 1位置不是*
                            num += (s[i + 1] <= '6' ? 2 : 1) * dp[i + 2];
                        else//两个位置都是*，11 12 ... 19 21 22 ... 26
                            num += 15 * dp[i + 2];
                    }
                }
            }
            num %= mod;
            dp[i] = num;
        }
        return dp[0];
    }
};
```
4. 空间压缩
```c++
class Solution {
private:
    static const long long mod = 1000000007;
public:
    int numDecodings(string s) {
        long long next = 1;
        long long nextNext = 0;
        for(int i = s.size() - 1; i >= 0; i--){
            long long num;
            if(s[i] == '0')
                num = 0;
            else{
                num = (s[i] == '*' ? 9 : 1) * next;  //一个位置解码，*可以表示1 - 9
                if(i + 1 < s.size()){   //可以进行两个位置解码
                    if(s[i] != '*'){
                        if(s[i + 1] != '*'){    //两个位置都不是*
                            if((s[i] - '0') * 10 + s[i + 1] - '0' <= 26)
                                num += nextNext;
                        }
                        else{   //i位置不是*，i + 1位置是*
                            if(s[i] == '1') //11 12 ... 19
                                num += 9 * nextNext; 
                            else if(s[i] == '2')    //21 22 ... 26
                                num += 6 * nextNext;
                        }
                    }
                    else{
                        if(s[i + 1] != '*') //i位置是*，i + 1位置不是*
                            num += (s[i + 1] <= '6' ? 2 : 1) * nextNext;
                        else//两个位置都是*，11 12 ... 19 21 22 ... 26
                            num += 15 * nextNext;
                    }
                }
            }
            num %= mod;
            nextNext = next;
            next = num;
        }
        return next;
    }
};
```

# 见识更多一维动态规划题目

当**熟悉了**从递归到动态规划的转化过程
那么就**可以纯粹用动态规划的视角来分析**问题了

## 相关题目

### 题目1：丑数Ⅱ
测试链接：https://leetcode.cn/problems/ugly-number-ii/
1. 利用set去重和排序
```c++
#include<set>
class Solution {
public:
    int nthUglyNumber(int n) {
        set<long long> s;   //去重和排序后的丑数集合
        s.insert(1);    //放入最小的丑数
        long long ans;
        for(int i = 1; i <= n; i++){
            //获得第i个丑数（当前集合中最小的就是）
            ans = *s.begin(); s.erase(s.begin());
            //向集合中插入新获得的丑数
            s.insert(ans * 2);
            s.insert(ans * 3);
            s.insert(ans * 5);
        }
        return ans;
    }
};
```
2. 三指针 + dp表缓存之前的结果
```c++
class Solution {
public:
    int nthUglyNumber(int n) {
        vector<int> dp(n + 1);
        dp[1] = 1;
        //第1个丑数已获得，每轮循环分别获得第i个丑数
        //i2, i3, i5分别指向不同的位置，每次比较时改位置指向的数字乘上对应的下标
        for(int i = 2, i2 = 1, i3 = 1, i5 = 1, a, b, c; i <= n; i++){
            a = dp[i2] * 2;
            b = dp[i3] * 3;
            c = dp[i5] * 5;
            dp[i] = min(min(a, b), c);
            //下面相等就往后暗含了去重
            if(dp[i] == a)  
                i2++;
            if(dp[i] == b)
                i3++;
            if(dp[i] == c)
                i5++;
            //dp[i]是a、b、c中的最小值，经历完3个判断语句后，下一轮的a,b,c是保证都能大于dp[i]的
        }
        return dp[n];
    }
};
```

### 题目2：最长有效括号
测试链接：https://leetcode.cn/problems/longest-valid-parentheses/
```c++
class Solution {
public:
    //有效的括号子串就两种关系：包含或者并列
    int longestValidParentheses(string s) {
        int n = s.size();
        vector<int> dp(n, 0);  //dp[0] = 0, 一个括号是不可能有效的
        //dp[i]表示以i为结尾的子串的最长有效括号子串
        for(int i = 1; i < n; i++){
            //以）结尾才有可能形成有效括号子串
            if(s[i] == ')'){
                //先找到能配对的位置，前面的已经形成有效括号子串的位置都得跳过
                int p = i - dp[i - 1] - 1;
                //p位置合法且能与i位置配对
                if(p >= 0 && s[p] == '('){
                    //p和i位置形成的括号包含了dp[i-1]的有效括号子串
                    //再加上与p和i位置形成的括号并列的有效括号子串
                    dp[i] = 2 + dp[i - 1] + (p - 1 >= 0 ? dp[p - 1] : 0);
                }
            }
        }
        int maxLen = 0;
        for(int i = 1; i < n; i++)
            maxLen = max(maxLen, dp[i]);
        return maxLen;
    }
}; 
```

### 题目3：环绕字符串中唯一的子字符串
测试链接：https://leetcode.cn/problems/unique-substrings-in-wraparound-string/
```c++
class Solution {
public:
    int findSubstringInWraproundString(string s) {
        int dp[26] = {0};   //以'a' - 'z'为结尾的最长子串
        for(int i = 0, len = 1; i < s.size(); i++){
            //还没破坏环绕字符串的形式，len++
            if(i - 1 >= 0 && s[i] == ((s[i - 1] - 'a' + 1) % 26) + 'a')
                len++;
            else    //已经破坏环绕字符串的结果，重新置为0
                len = 1;
            dp[s[i] - 'a'] = max(dp[s[i] - 'a'], len);
        }
        int cnt = 0; 
        for(int i = 0; i < 26; i++)
            cnt += dp[i];
        return cnt;
    }
};
```

### 题目4：不同的子序列Ⅱ
测试链接：https://leetcode.cn/problems/distinct-subsequences-ii/
```c++
class Solution {
private:
    const int mod = 1000000007;
public:
    int distinctSubseqII(string s) {
        int dp[26] = {0};   //以每个字母结尾的子序列个数
        int all = 1; //一开始只有一个空序列
        for(char ch : s){
            //因为序列一直保留，所以要减去之前算过的不能重复算
            //就是没算过的序列后面加上当前字符才能组成新序列
            int newAdd = (all - dp[ch - 'a'] + mod) % mod;    
            dp[ch - 'a'] = (dp[ch - 'a'] + newAdd) % mod;
            all = (all + newAdd) % mod;
        }
        return (all - 1 + mod) % mod; //减去初始的空序列
    }
};
```

# 从递归入手二维动态规划

尝试函数有两个可变参数**可以完全决定返回值**，那么就可以改出二维动态规划的实现

二维动态规划依然需要去整理**动态规划表的格子之间的依赖关系**
找寻依赖关系，往往**通过画图来建立空间感**，使其更显而易见
然后依然是**从简单格子填写到复杂格子**的过程，即严格位置依赖的动态规划（从底到顶）

二维动态规划的压缩空间技巧原理不难，会了之后千篇一律
但是**不同题目依赖关系不一样**，需要**很细心的画图来整理具体题目的依赖关系**
最后进行空间压缩的实现

## 相关题目

### 题目1：最小路径和
测试链接：https://leetcode.cn/problems/minimum-path-sum/
1. 暴力递归
```c++
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        int m = grid.size();
        int n = grid[0].size();
        return f(grid, m - 1, n - 1);
    }
    //求解(0, 0) -> (i, j)的路径最小和
    int f(vector<vector<int>>& grid, int i, int j){
        //位置不中网格中，路径不存在
        if(i < 0 || j < 0)
            return INT_MAX;
        if(i == 0 && j == 0)
            return grid[0][0];
        return min(f(grid, i - 1, j), f(grid, i, j - 1)) + grid[i][j];
    }
};
```
2. 记忆化搜索
```c++
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        int m = grid.size();
        int n = grid[0].size();
        vector<vector<int>> dp(m, vector<int>(n, -1));
        return f(grid, m - 1, n - 1, dp);
    }
    //求解(0, 0) -> (i, j)的路径最小和
    int f(vector<vector<int>>& grid, int i, int j, vector<vector<int>> &dp){
        //位置不中网格中，路径不存在
        if(i < 0 || j < 0)
            return INT_MAX;
        if(dp[i][j] != -1)
            return dp[i][j];
        int ans;
        if(i == 0 && j == 0)
            ans =  grid[0][0];
        else
            ans = min(f(grid, i - 1, j, dp), f(grid, i, j - 1, dp)) + grid[i][j];
        dp[i][j] = ans;
        return ans;
    }
};
```
3. 严格位置依赖的动态规划
```c++
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        int m = grid.size();
        int n = grid[0].size();
        vector<vector<int>> dp(m, vector<int>(n));
        dp[0][0] = grid[0][0];
        for(int i = 1; i < n; i++)
            dp[0][i] = dp[0][i - 1] + grid[0][i];
        for(int i = 1; i < m; i++)
            dp[i][0] = dp[i - 1][0] + grid[i][0];
        for(int i = 1; i < m; i++){
            for(int j = 1; j < n; j++)
                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
        }
        return dp[m - 1][n - 1];
    }
};
```
4. 空间压缩
```c++
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        int m = grid.size();
        int n = grid[0].size();
        vector<int> dp(n);
        dp[0] = grid[0][0];
        for(int i = 1; i < n; i++)
            dp[i] = dp[i - 1] + grid[0][i];
        for(int i = 1; i < m; i++){
            //一行一行填
            dp[0] += grid[i][0];
            for(int j = 1; j < n; j++)
                dp[j] = min(dp[j - 1], dp[j]) + grid[i][j];
        }
        return dp[n - 1];
    }
};
```

### 题目2：最长公共子序列
测试链接：https://leetcode.cn/problems/longest-common-subsequence/
1. 普通的暴力递归
```c++
class Solution {
public:
    int longestCommonSubsequence1(string text1, string text2) {
        int len1 = text1.size();
        int len2 = text2.size();
        return f1(text1, text2, len1 - 1, len2 - 1);
    }
    //s1[0...i], s2[0...j]的最长公共子序列
    int f1(const string &s1, const string &s2, int i, int j){
        //区间上一个字符都没有
        if(i < 0 || j < 0)
            return 0;
        int ans;
        if(s1[i] == s2[j])
            ans = f1(s1, s2, i - 1, j - 1) + 1;
        else
            ans = max(f1(s1, s2, i - 1, j), f1(s1, s2, i, j - 1));
        return ans;
    }

    //对应的记忆化搜索
    int longestCommonSubsequence(string text1, string text2) {
        int len1 = text1.size();
        int len2 = text2.size();
        vector<vector<int>> dp(len1, vector<int>(len2, -1));
        return f(text1, text2, len1 - 1, len2 - 1, dp);
    }
    //s1[0...i], s2[0...j]的最长公共子序列
    int f(const string &s1, const string &s2, int i, int j, vector<vector<int>> &dp){
        //区间上一个字符都没有
        if(i < 0 || j < 0)
            return 0;
        if(dp[i][j] != -1)
            return dp[i][j];
        int ans;
        if(s1[i] == s2[j])
            ans = f(s1, s2, i - 1, j - 1, dp) + 1;
        else
            ans = max(f(s1, s2, i - 1, j, dp), f(s1, s2, i, j - 1, dp));
        dp[i][j] = ans;
        return ans;
    }
};
```
2. 优化后节省很多边界讨论的暴力递归，记忆化搜索哪个都行，但是严格位置依赖的动态规划就很需要了
```c++
class Solution {
public:
    int longestCommonSubsequence1(string text1, string text2) {
        int len1 = text1.size();
        int len2 = text2.size();
        return f1(text1, text2, len1, len2);
    }
    //s1[0...len1 - 1], s2[0...len2 - 1]的最长公共子序列
    int f1(const string &s1, const string &s2, int len1, int len2){
        //区间上一个字符都没有
        if(len1 == 0 || len2 == 0)
            return 0;
        int ans;
        if(s1[len1 - 1] == s2[len2 - 1])
            ans = f1(s1, s2, len1 - 1, len2 - 1) + 1;
        else
            ans = max(f1(s1, s2, len1 - 1, len2), f1(s1, s2, len1, len2 - 1));
        return ans;
    }

    //对应的记忆化搜索
    int longestCommonSubsequence(string text1, string text2) {
        int len1 = text1.size();
        int len2 = text2.size();
        vector<vector<int>> dp(len1 + 1, vector<int>(len2 + 1, - 1));
        return f(text1, text2, len1, len2, dp);
    }
    //s1[0...len1 - 1], s2[0...len2 - 1]的最长公共子序列
    int f(const string &s1, const string &s2, int len1, int len2, vector<vector<int>> &dp){
        //区间上一个字符都没有
        if(len1 == 0 || len2 == 0)
            return 0;
        if(dp[len1][len2] != -1)
            return dp[len1][len2];
        int ans;
        if(s1[len1 - 1] == s2[len2 - 1])
            ans = f(s1, s2, len1 - 1, len2 - 1, dp) + 1;
        else
            ans = max(f(s1, s2, len1 - 1, len2, dp), f(s1, s2, len1, len2 - 1, dp));
        dp[len1][len2] = ans;
        return ans;
    }
};
```
3. 严格位置依赖的动态规划
```c++
class Solution {
public:
    int longestCommonSubsequence(string s1, string s2) {
        int n = s1.size();
        int m = s2.size();
        vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));
        for(int len1 = 1, ans; len1 <= n; len1++){
            for(int len2 = 1; len2 <= m; len2++){
                if(s1[len1 - 1] == s2[len2 - 1])
                    ans = dp[len1 - 1][len2 - 1] + 1;
                else
                    ans = max(dp[len1 - 1][len2], dp[len1][len2 - 1]);
                dp[len1][len2] = ans;
            }
        }
        return dp[n][m];
    }
};
```
4. 空间优化
```c++
class Solution {
public:
    int longestCommonSubsequence(string s1, string s2) {
        int n = s1.size();
        int m = s2.size();
        vector<int> dp(m + 1, 0);
        for(int len1 = 1, ans; len1 <= n; len1++){
            for(int len2 = 1, leftUP = dp[0]; len2 <= m; len2++){
                if(s1[len1 - 1] == s2[len2 - 1])
                    ans = leftUP + 1;
                else
                    ans = max(dp[len2], dp[len2 - 1]); //左和上
                leftUP = dp[len2];
                dp[len2] = ans;
            }
        }
        return dp[m];
    }
};
```

### 题目3：最长回文子序列
测试链接：https://leetcode.cn/problems/longest-palindromic-subsequence/
1. 暴力递归 + 记忆化搜索
```c++
class Solution {
public:
    int longestPalindromeSubseq1(string s) { 
        return f1(s, 0, s.size() - 1); 
    }
    // 区间[l, r]上的最长回文子序列长度
    int f1(const string& s, int l, int r) {
        if (l == r)
            return 1;
        if (l + 1 == r)
            return s[l] == s[r] ? 2 : 1;
        int ans;
        if (s[l] == s[r])
            ans = 2 + f1(s, l + 1, r - 1);
        else
            ans = max(f1(s, l + 1, r), f1(s, l, r - 1));
        return ans;
    }

    //该递归对应的记忆化搜索版本，可以通过测试
    int longestPalindromeSubseq(string s) { 
        int n = s.size();
        vector<vector<int>> dp(n, vector<int>(n, -1));
        return f(s, 0, n - 1, dp); 
    }
    // 区间[l, r]上的最长回文子序列长度
    int f(const string& s, int l, int r, vector<vector<int>> &dp) {
        if (l == r)
            return 1;
        if (l + 1 == r)
            return s[l] == s[r] ? 2 : 1;
        if(dp[l][r] != -1)
            return dp[l][r];
        int ans;
        if (s[l] == s[r])
            ans = 2 + f(s, l + 1, r - 1, dp);
        else
            ans = max(f(s, l + 1, r, dp), f(s, l, r - 1, dp));
        dp[l][r] = ans;
        return ans;
    }
};
```
2. 严格位置依赖的动态规划
```c++
class Solution {
public:
    int longestPalindromeSubseq(string s) { 
        int n = s.size();
        vector<vector<int>> dp(n, vector<int>(n));
        for(int l = n - 1; l >= 0; l--){
            dp[l][l] = 1;
            if(l + 1 < n)
                dp[l][l + 1] = (s[l] == s[l + 1] ? 2 : 1);
            for(int r = l + 2, ans; r < n; r++){
                if (s[l] == s[r])
                    ans = 2 + dp[l + 1][r - 1];
                else
                    ans = max(dp[l + 1][r], dp[l][r - 1]);
                dp[l][r] = ans;
            }
        }
        return dp[0][n - 1]; 
    }
};
```
3. 空间优化
```c++
class Solution {
public:
    int longestPalindromeSubseq(string s) { 
        int n = s.size();
        vector<int> dp(n);
        for(int l = n - 1; l >= 0; l--){
            dp[l] = 1;
            if(l + 1 < n)
                dp[l + 1] = (s[l] == s[l + 1] ? 2 : 1);
            //一开始左下方就是对角线上的点
            for(int r = l + 2, ans, leftDown = 1; r < n; r++){
                if (s[l] == s[r])
                    ans = 2 + leftDown;
                else
                    ans = max(dp[r], dp[r - 1]);
                //更新左下方的点
                leftDown = dp[r];
                dp[r] = ans;
            }
        }
        return dp[n - 1]; 
    }
};
```

### 题目4：节点数为n高度不大于m的二叉树个数
测试链接：https://www.nowcoder.com/practice/aaefe5896cce4204b276e213e725f3ea
1. 暴力递归 + 记忆化搜索
```c++
#include <iostream>
using namespace std;

const long long mod = 1000000007;
const int MAXN = 55;
long long dp[MAXN][MAXN];

long long ways(int n, int m) {
    //没有节点了，高度为多少都会满足
    if (n == 0)
        return 1;
    //存在节点且高度要求 <= 0，这谁顶得住
    if (m == 0)
        return 0;
    if(dp[n][m] != -1)
        return dp[n][m];
    //一个节点作为根，左右子树总共n - 1个节点
    long long ans = 0;
    for (int left = 0, right = n - 1; left < n; left++, right--) {
        ans = (ans + ways(left, m - 1) * ways(right, m - 1) % mod) % mod;
    }
    dp[n][m] = ans;
    return ans;
}

int main() {
    int n, m;
    cin >> n >> m;
    for(int i = 1; i <= n; i++){
        for(int j = 1; j <= m; j++)
            dp[i][j] = -1;
    }
    cout << ways(n, m) << endl;
}
```
2. 严格位置依赖的动态规划
```c++
#include <iostream>
using namespace std;

const long long mod = 1000000007;
const int MAXN = 55;
long long dp[MAXN][MAXN];

long long ways(int n, int m) {
    for (int i = 0; i <= m; i++)
        dp[0][i] = 1;
    for (int i = 1; i <= n; i++)
        dp[i][0] = 0;

    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            long long ans = 0;
            for (int left = 0, right = j - 1; left < j; left++, right--)
                ans = (ans + dp[left][i - 1] * dp[right][i - 1] % mod) % mod;
            dp[j][i] = ans;
        }
    }
    return dp[n][m];
}

int main() {
    int n, m;
    cin >> n >> m;
    cout << ways(n, m) << endl;
}
```
3. 空间压缩
```c++
#include <iostream>
using namespace std;

const long long mod = 1000000007;
const int MAXN = 55;
long long dp[MAXN];

long long ways(int n, int m) {
    dp[0] = 1;
    //一列一列的填，每一列下面的行依赖前一列上面行东西
    //所以同一列，从下往上填（都能用到上一列的信息）
    for (int i = 1; i <= m; i++) {
        for (int j = n; j > 0; j--) {
            long long ans = 0;
            for (int left = 0, right = j - 1; left < j; left++, right--)
                ans = (ans + dp[left] * dp[right] % mod) % mod;
            dp[j] = ans;
        }
    }
    return dp[n];
}

int main() {
    int n, m;
    cin >> n >> m;
    cout << ways(n, m) << endl;
}
```

### 题目5：矩阵中的最长递增路径
位置依赖不确定，无法改成严格位置依赖的动态规划，到记忆化搜索就结束了
测试链接：https://leetcode.cn/problems/longest-increasing-path-in-a-matrix/
```c++
class Solution {
private:
    static constexpr int move[5] = {-1, 0, 1, 0, -1};
    int m, n;
public:
    int longestIncreasingPath(vector<vector<int>>& matrix) {
        m = matrix.size();
        n = matrix[0].size();
        vector<vector<int>> dp(m, vector<int>(n, -1));
        int ans = 0;
        for(int i = 0; i < m; i++){
            for(int j = 0; j < n; j++){
                ans = max(ans, f(matrix, i, j, dp));
            }   
        }
        return ans;
    }
    //从(i, j)位置出发，找到的最长递增路径的长度
    int f(vector<vector<int>>& matrix, int i, int j, vector<vector<int>> &dp){
        if(dp[i][j] != -1)
            return dp[i][j];
        int ans = 0;
        for(int k = 0, ni, nj; k < 4; k++){
            ni = i + move[k];
            nj = j + move[k + 1];
            //周围是否有递增的路径，有就走
            if(ni >= 0 && ni < m && nj >= 0 && nj < n && matrix[ni][nj] > matrix[i][j])
                ans = max(ans, f(matrix, ni, nj, dp));
        }
        dp[i][j] = ans + 1;
        //包括自己的最长递增路径
        return ans + 1;
    }
};
```

# 见识更多二维动态规划题目

直接从动态规划的定义入手，来见识更多二维动态规划问题

## 相关问题

### 题目1：不同的子序列
测试链接：https://leetcode.cn/problems/distinct-subsequences/
1. 严格位置依赖的动态规划
```c++
class Solution {
private:
    static const int mod = 1000000007;
public:
    //dp[i][j]表示s[i长度]子序列中出现t[j]长度的个数
    //情况一：s[i - 1] == t[j - 1] 
    //dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]
    //情况二：s[i - 1] != s[j - 1]
    //dp[i][j] = dp[i - 1][j]
    //j == 0时，dp[i][j] = 1，因为肯定有一个空序列与之对应
    //i == 0 && j != 1时，dp[i][j] = 0，因为不可能无中生有 
    int numDistinct(string s, string t) {
        int n = s.size();
        int m = t.size();
        vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));
        for(int i = 0; i <= n; i++)
            dp[i][0] = 1;
        for(int i = 1; i <= n; i++){
            for(int j = 1; j <= m; j++){
                //不管最后一个字符
                dp[i][j] = dp[i - 1][j];
                //最后一个字符相等，看看前面的能不能配上
                if(s[i - 1] == t[j - 1])
                    dp[i][j] = (dp[i][j] + dp[i - 1][j - 1]) % mod;
            }
        }
        return dp[n][m];
    }
};
```
2. 空间压缩
```c++
class Solution {
private:
    static const int mod = 1000000007;
public:
    //dp[i][j]表示s[i长度]子序列中出现t[j]长度的个数
    //情况一：s[i - 1] == t[j - 1] 
    //dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]
    //情况二：s[i - 1] != s[j - 1]
    //dp[i][j] = dp[i - 1][j]
    //j == 0时，dp[i][j] = 1，因为肯定有一个空序列与之对应
    //i == 0 && j != 1时，dp[i][j] = 0，因为不可能无中生有 
    int numDistinct(string s, string t) {
        int n = s.size();
        int m = t.size();
        vector<int> dp(m + 1, 0);
        dp[0] = 1;
        for(int i = 1; i <= n; i++){
            //<-----每行从右到左去填，能够同时用到上方和左上方的格子
            for(int j = m; j > 0; j--){
                //最后一个字符相等，看看前面的能不能配上
                if(s[i - 1] == t[j - 1])
                    dp[j] = (dp[j] + dp[j - 1]) % mod;
            }
        }
        return dp[m];
    }
};
```

### 题目2：编辑距离
测试链接：https://leetcode.cn/problems/edit-distance/
1. 严格位置依赖的动态规划
```c++
class Solution {
public:
    int minDistance(string word1, string word2) {
        return editDistance(word1, word2, 1, 1, 1);
    }
    // 给你两个单词 s 和 t
    // 请返回将 s 转换成 t 所使用的最少代价
    // 你可以对一个单词进行如下三种操作：
    // 插入一个字符，代价a
    // 删除一个字符，代价b
    // 替换一个字符，代价c
    // dp[i][j]表示 s[i长度] 转换成 t[j长度]所使用的最少代价
    // 情况一：s[i长度] 转换成 t[j - 1长度] + 插入一个t[j - 1](a)
    // 即p1 = dp[i][j - 1] + a
    // 情况二：s[i - 1长度] 转换成 t[j长度] + 删除一个s[i - 1](b)
    // 即p2 = dp[i - 1][j] + b
    // 情况三：s[i - 1长度] 转换成 t[j - 1长度] + s[i - 1] 替换成 t[j - 1]（s[i - 1] != t[j - 1）才需要替换代价（c）
    // 即p3 = dp[i - 1][j - 1] + (s[i - 1] != t[j - 1] ? c : 0)
    int editDistance(const string &s, const string &t, int a, int b, int c){
        int n = s.size();
        int m = t.size();
        vector<vector<int>> dp(n + 1, vector<int>(m + 1));
        dp[0][0] = 0; //空到空无需代价
        //空 变成 t[j长度] 需要插入j个字符的代价
        for(int j = 1; j <= m; j++)
            dp[0][j] = j * a; 
        //s[i长度] 变成 空 需要删除i个字符的代价
        for(int i = 1; i <= n; i++)
            dp[i][0] = i * b;
        for(int i = 1, p1, p2, p3; i <= n; i++){
            for(int j = 1; j <= m; j++){
                p1 = dp[i][j - 1] + a;
                p2 = dp[i - 1][j] + b;
                p3 = dp[i - 1][j - 1] + (s[i - 1] != t[j - 1] ? c : 0);
                dp[i][j] = min(p1, min(p2, p3));
            }
        }
        return dp[n][m];
    }
};
```
2. 空间优化
```c++
class Solution {
public:
    int minDistance(string word1, string word2) {
        return editDistance(word1, word2, 1, 1, 1);
    }
    int editDistance(const string &s, const string &t, int a, int b, int c){
        int n = s.size();
        int m = t.size();
        vector<int> dp(m + 1);
        dp[0] = 0;
        //空 变成 t[j长度] 需要插入j个字符的代价
        for(int j = 1; j <= m; j++)
            dp[j] = j * a; 
        for(int i = 1, p1, p2, p3, leftUp; i <= n; i++){
            leftUp = dp[0];
            dp[0] += b; //多删除一个字符
            for(int j = 1; j <= m; j++){
                p1 = dp[j - 1] + a;
                p2 = dp[j] + b;
                p3 = leftUp + (s[i - 1] != t[j - 1] ? c : 0);
                leftUp = dp[j];
                dp[j] = min(p1, min(p2, p3));
            }
        }
        return dp[m];
    }
};
```

### 题目3：交错字符串
测试链接：https://leetcode.cn/problems/interleaving-string/
1. 严格位置依赖的动态规划
```c++
class Solution {
public:
    // dp[i][j]表示s1[i长度]和s2[j长度]能否交错形成s3[i + j长度]
    // 一开始dp[i][j] = false，假设无法交错形成s3
    // 可能性1：s1[i - 1] == s3[i + j - 1]，dp[i][j] = dp[i][j] || dp[i - 1][j]
    // 可能性2：s2[j - 1] == s3[i + j - 1]，dp[i][j] = dp[i][j] || dp[i][j - 1]
    bool isInterleave(string s1, string s2, string s3) {
        int n = s1.size();
        int m = s2.size();
        if(n + m != s3.size())
            return false;
        vector<vector<bool>> dp(n + 1, vector<bool>(m + 1, false));
        //空串和空串交错形成空串，可行
        dp[0][0] = true;
        //空串和s2[j长度]能否交错构成s3[j长度]
        for(int j = 1; j <= m; j++){
            if(s2[j - 1] != s3[j - 1])
                break;
            dp[0][j] = true;
        }
        //s1[i长度]能否交错构成s3[i长度]
        for(int i = 1; i <= n; i++){
            if(s1[i - 1] != s3[i - 1])
                break;
            dp[i][0] = true;
        }
        for(int i = 1; i <= n; i++){
            for(int j = 1; j <= m; j++){
                if(s1[i - 1] == s3[i + j - 1])
                    dp[i][j] = dp[i][j] || dp[i - 1][j];
                if(s2[j - 1] == s3[i + j - 1])
                    dp[i][j] = dp[i][j] || dp[i][j - 1];
                // dp[i][j] = (s1[i - 1] == s3[i + j - 1] && dp[i - 1][j]) || 
                //             (s2[j - 1] == s3[i + j - 1] && dp[i][j - 1]);
            }
        }
        return dp[n][m];
    }
};
```
2. 空间优化
```c++
class Solution {
public:
    bool isInterleave(string s1, string s2, string s3) {
        int n = s1.size();
        int m = s2.size();
        if(n + m != s3.size())
            return false;
        vector<bool> dp(m + 1, false);
        //空串和空串交错形成空串，可行
        dp[0] = true;
        //空串和s2[j长度]能否交错构成s3[j长度]
        for(int j = 1; j <= m; j++){
            if(s2[j - 1] != s3[j - 1])
                break;
            dp[j] = true;
        }
        for(int i = 1; i <= n; i++){
            dp[0] = s1[i - 1] == s3[i - 1] && dp[0];
            for(int j = 1; j <= m; j++){
                //上方的格子
                dp[j] = dp[j] && s1[i - 1] == s3[i + j - 1];    
                if(s2[j - 1] == s3[i + j - 1])
                    dp[j] = dp[j] || dp[j - 1];
            }
        }
        return dp[m];
    }
};
```

### 题目4：有效涂色问题

> 给定n、m两个参数
一共有n个格子，每个格子可以涂上一种颜色，颜色在m种里选
当涂满n个格子，并且m种颜色都使用了，叫一种有效方法
求一共有多少种有效的涂色方法
1 <= n, m <= 5000
结果比较大请 % 1000000007 之后返回
**对数器验证**
```c++
#include <iostream>
#include <vector>
#include <chrono>
using namespace std;

const long long mod = 1000000007;
const int MAXN = 5005;
int dp[MAXN][MAXN];

//dp[i][j]表示i个格子涂上j中颜色的有效方法数
//情况一：i - 1个格子涂上了j种颜色，第i个格子j种颜色选一个，不能再多出一种颜色了
//情况二：i - 1个格子涂上了j - 1种颜色，第i个格子(m - (j - 1))种颜色选一个，还得多出一种没出现过的颜色
int ways(int n, int m) {
    //i个格子得有1种颜色
    for (int i = 1; i <= n; i++)
        dp[i][1] = m;
    for (int i = 2; i <= n; i++) {
        for (int j = 2; j <= m; j++) {
            dp[i][j] = (((long long)dp[i - 1][j] * j % mod) + ((long long)dp[i - 1][j - 1] * (m - j + 1) % mod)) % mod;
        }
    }
    return dp[n][m];
}

int f(vector<int>& path, vector<bool>& set, int i, int n, int m) {
    if (i == n) {
        fill(set.begin(), set.end(), false);
        int colors = 0;
        for (int c : path) {
            if (!set[c]) {
                set[c] = true;
                colors++;
            }
        }
        return colors == m ? 1 : 0;
    }
    else {
        int ans = 0;
        for (int j = 1; j <= m; j++) {
            path[i] = j;
            ans += f(path, set, i + 1, n, m);
        }
        return ans;
    }
}


int ways1(int n, int m) {
    vector<int> path(n, 0);
    vector<bool> set(m + 1, false);
    return f(path, set, 0, n, m);
}


int main() {
    // 测试的数据量比较小
    // 那是因为数据量大了，暴力方法过不了
    // 但是这个数据量足够说明正式方法是正确的
    int N = 9;
    int M = 9;
    cout << "功能测试开始" << endl;
    for (int n = 1; n <= N; n++) {
        for (int m = 1; m <= M; m++) {
            int ans1 = ways1(n, m);
            int ans2 = ways(n, m);
            if (ans1 != ans2) {
                cout << "出错了!" << endl;
            }
        }
    }
    cout << "功能测试结束" << endl;

    cout << "性能测试开始" << endl;
    int n = 5000;
    int m = 4877;
    cout << "n : " << n << endl;
    cout << "m : " << m << endl;
    auto start = chrono::steady_clock::now();
    int ans = ways(n, m);
    auto end = chrono::steady_clock::now();
    cout << "取余之后的结果 : " << ans << endl;
    cout << "运行时间 : " << chrono::duration_cast<chrono::milliseconds>(end - start).count() << " 毫秒" << endl;
    cout << "性能测试结束" << endl;

    return 0;
}
```

### 题目5：删除至少几个字符可以变成另一个字符串的子串
> 给定两个字符串s1和s2
返回s1至少删除多少字符可以成为s2的子串
**对数器验证**
```c++
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>

using namespace std;

// 生成s1字符串的所有子序列串
void generateSubsequences(const string& s1, int index, string path, vector<string>& subsequences) {
    if (index == s1.length()) {
        subsequences.push_back(path);
    }
    else {
        generateSubsequences(s1, index + 1, path, subsequences);
        generateSubsequences(s1, index + 1, path + s1[index], subsequences);
    }
}

// 暴力方法
int minDelete1(const string& s1, const string& s2) {
    vector<string> subsequences;
    generateSubsequences(s1, 0, "", subsequences);

    // 排序 : 长度大的子序列先考虑
    // 因为如果长度大的子序列是s2的子串
    // 那么需要删掉的字符数量 = s1的长度 - s1子序列长度
    // 子序列长度越大，需要删掉的字符数量就越少
    // 所以长度大的子序列先考虑
    sort(subsequences.begin(), subsequences.end(), [](const string& a, const string& b) {
        return a.length() > b.length();
        });

    for (const string& sub : subsequences) {
        if (s2.find(sub) != string::npos) {
            // 检查s2中，是否包含当前的s1子序列sub
            return s1.length() - sub.length();
        }
    }

    return s1.length();
}

//dp[i][j]表示s1[i长度]至少删除多少字符可以变成s2[j长度]的后缀串
//情况一：s1[i - 1] != s2[j - 1]，s1的最后一个字符肯定要删掉
//dp[i][j] = dp[i - 1][j] + 1
//情况二：s1[i - 1] == s2[j - 1]
//dp[i][j] = dp[i - 1][j - 1]
int minDelete(const string& s1, const string& s2) {
    int n = s1.size();
    int m = s2.size();
    vector<vector<int>> dp(n + 1, vector<int>(m + 1));
    for (int i = 1; i <= n; i++) {
        dp[i][0] = i;   //删掉所有字符才能变成空串的后缀串
        for (int j = 1; j <= m; j++) {
            dp[i][j] = s1[i - 1] != s2[j - 1] ? dp[i - 1][j] + 1 : dp[i - 1][j - 1];
        }
    }
    int minDel = INT_MAX;
    for (int j = 0; j <= m; j++) {
        minDel = min(minDel, dp[n][j]);
    }
    return minDel;
}

// 生成长度为n，有v种字符的随机字符串
string randomString(int n, int v) {
    string result = "";
    for (int i = 0; i < n; i++) {
        result += char('a' + rand() % v);
    }
    return result;
}

// 对数器
int main() {
    srand(time(nullptr));
    int n = 12;
    int v = 3;
    int testTime = 20000;
    cout << "测试开始" << endl;
    for (int i = 0; i < testTime; i++) {
        int len1 = rand() % n + 1;
        int len2 = rand() % n + 1;
        string s1 = randomString(len1, v);
        string s2 = randomString(len2, v);
        int ans1 = minDelete1(s1, s2);
        int ans2 = minDelete(s1, s2);
        if (ans1 != ans2) {
            cout << "出错了!" << endl;
        }
    }
    cout << "测试结束" << endl;
    return 0;
}
```

# 从递归入手三维动态规划

尝试函数有3个可变参数**可以完全决定返回值**，那么就可以改出3维动态规划的实现

## 相关题目

### 题目1：一和零（多维费用背包）
测试链接：https://leetcode.cn/problems/ones-and-zeroes/
1. 暴力递归 -> 记忆化搜索
```c++
class Solution {
private:
    int zero, one;
    void zeroAndOne(const string &s){
        zero = one = 0;
        for(char ch : s)
            ch == '0' ? zero++ : one++;
    }
public:
    int findMaxForm(vector<string>& strs, int m, int n) {
        int len = strs.size();
        vector<vector<vector<int>>> dp(len + 1, vector<vector<int>> (m + 1, vector<int>(n + 1, -1)));
        return f(strs, 0, m, n, dp);
    }
    //返回 strs[i...end] 的最大子集的长度，该子集中 最多 有 z 个 0 和 o 个 1
    int f(vector<string>& strs, int i, int z, int o, vector<vector<vector<int>>> &dp){
        //集合长度为0，子集长度肯定为0
        if(i == strs.size())
            return 0;
        if(dp[i][z][o] != -1)
            return dp[i][z][o];
        int ans = f(strs, i + 1, z, o, dp); //不选
        zeroAndOne(strs[i]);
        if(zero <= z && one <= o)
            ans = max(ans, 1 + f(strs, i + 1, z - zero, o - one, dp));  //能选且选了
        dp[i][z][o] = ans;
        return ans;
    }
};
```
2. 严格位置依赖的动态规划
```c++
class Solution {
private:
    int zero, one;
    void zeroAndOne(const string &s){
        zero = one = 0;
        for(char ch : s)
            ch == '0' ? zero++ : one++;
    }
public:
    int findMaxForm(vector<string>& strs, int m, int n) {
        int len = strs.size();
        vector<vector<vector<int>>> dp(len + 1, vector<vector<int>> (m + 1, vector<int>(n + 1, 0)));
        for(int i = len - 1; i >= 0; i--){
            zeroAndOne(strs[i]);
            for(int z = 0; z <= m; z++){
                for(int o = 0; o <= n; o++){
                    int ans = dp[i + 1][z][o];
                    if(zero <= z && one <= o)
                        ans = max(ans, 1 + dp[i + 1][z - zero][o - one]);
                    dp[i][z][o] = ans;
                }
            }
        }
        return dp[0][m][n];
    }
};
```
3. 空间压缩
```c++
class Solution {
private:
    int zero, one;
    void zeroAndOne(const string &s){
        zero = one = 0;
        for(char ch : s)
            ch == '0' ? zero++ : one++;
    }
public:
    int findMaxForm(vector<string>& strs, int m, int n) {
        int len = strs.size();
        vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));
        //字符串什么顺序无所谓了
        for(const string &str : strs){
            zeroAndOne(str);
            //倒着填，需要依赖最多的位置先填
            for(int z = m; z >= zero; z--){
                for(int o = n; o >= one; o--){
                    dp[z][o] = max(dp[z][o], 1 + dp[z - zero][o - one]);
                }
            }
        }
        return dp[m][n];
    }
};
```

### 题目2：盈利计划（多维费用背包）
测试链接：https://leetcode.cn/problems/profitable-schemes/
1. 暴力递归 -> 记忆化搜索
```c++
class Solution {
private:
    static const int mod = 1000000007;
public:
    int profitableSchemes(int n, int minProfit, vector<int>& group, vector<int>& profit) {
        vector<vector<vector<int>>> dp(group.size(), vector<vector<int>>(n + 1, vector<int>(minProfit + 1, -1)));
        return f(group, profit, 0, n, minProfit, dp);
    }
    int f(vector<int>& group, vector<int>& profit, int i, int restWorker, int restProfit, vector<vector<vector<int>>> &dp){
        //没有员工了，后面都不选就是一种方案
        if(restWorker == 0)
            return restProfit == 0 ? 1 : 0; //判断是否是盈利计划
        //工作都干完了，是一种方案
        if(i == group.size())
            return restProfit == 0 ? 1 : 0; //判断是否是盈利计划
        if(dp[i][restWorker][restProfit] != -1)
            return dp[i][restWorker][restProfit];
        //不干i工作
        int ans = f(group, profit, i + 1, restWorker, restProfit, dp);
        //员工够完成该任务才去尝试
        //max(restProfit - profit[i], 0)将restProfit < 0的状态全部压缩到restProfit == 0
        if(restWorker >= group[i])
            ans = (ans + f(group, profit, i + 1, restWorker - group[i], max(restProfit - profit[i], 0), dp)) % mod;
        dp[i][restWorker][restProfit] = ans;
        return ans;
    }
};
```
2. 严格位置依赖的动态规划
```c++
class Solution {
private:
    static const int mod = 1000000007;
public:
    int profitableSchemes(int n, int minProfit, vector<int>& group, vector<int>& profit) {
        vector<vector<vector<int>>> dp(group.size() + 1, vector<vector<int>>(n + 1, vector<int>(minProfit + 1, 0)));
        for(int restWorker = 0; restWorker <= n; restWorker++)
            dp[group.size()][restWorker][0] = 1;
        for(int i = group.size() - 1; i >= 0; i--){
            for(int restWorker = 0; restWorker <= n; restWorker++){
                for(int restProfit = 0; restProfit <= minProfit; restProfit++){
                    //不干i工作
                    int ans = dp[i + 1][restWorker][restProfit];
                    //员工够完成该任务才去尝试
                    //max(restProfit - profit[i], 0)将restProfit <= 0的状态全部压缩到restProfit == 0
                    if(restWorker >= group[i])
                        ans = (ans + dp[i + 1][restWorker - group[i]][max(restProfit - profit[i], 0)]) % mod;
                    dp[i][restWorker][restProfit] = ans;
                }
            }
        }
        return dp[0][n][minProfit];
    }
};
```
3. 空间压缩
```c++
class Solution {
private:
    static const int mod = 1000000007;
public:
    int profitableSchemes(int n, int minProfit, vector<int>& group, vector<int>& profit) {
        vector<vector<int>> dp(n + 1, vector<int>(minProfit + 1, 0));
        for(int restWorker = 0; restWorker <= n; restWorker++)
            dp[restWorker][0] = 1;
        for(int i = group.size() - 1; i >= 0; i--){
            for(int restWorker = n; restWorker >= 0; restWorker--){
                for(int restProfit = minProfit; restProfit >= 0; restProfit--){
                    // //不干i工作
                    // int ans = dp[restWorker][restProfit];
                    //员工够完成该任务才去尝试
                    // //max(restProfit - profit[i], 0)将restProfit <= 0的状态全部压缩到restProfit == 0
                    // if(restWorker >= group[i])
                    //     ans = (ans + dp[restWorker - group[i]][max(restProfit - profit[i], 0)]) % mod;
                    // dp[restWorker][restProfit] = ans;
                    if(restWorker >= group[i])
                        dp[restWorker][restProfit] = (dp[restWorker][restProfit] + dp[restWorker - group[i]][max(restProfit - profit[i], 0)]) % mod;
                }
            }
        }
        return dp[n][minProfit];
    }
};
```

### 题目3：骑士在棋盘上的概率
测试链接：https://leetcode.cn/problems/knight-probability-in-chessboard/
位置依赖过于复杂，只有记忆化搜索版本
```c++
class Solution {
private:
    static constexpr int move[8][2] = {{-1, -2}, {-2, -1}, {-2, 1}, {-1, 2},
                                       {1, -2},  {2, -1},  {2, 1},  {1, 2}};

public:
    double knightProbability(int n, int k, int row, int column) {
        vector<vector<vector<double>>> dp(
            k + 1, vector<vector<double>>(n, vector<double>(n, -1)));
        return f(n, k, row, column, dp);
    }
    double f(int n, int rest, int i, int j,
             vector<vector<vector<double>>>& dp) {
        if (i < 0 || i >= n || j < 0 || j >= n)
            return 0;
        if (dp[rest][i][j] != -1)
            return dp[rest][i][j];
        double ans = 0;
        if (rest == 0)
            ans = 1;
        else {
            for (int k = 0; k < 8; k++)
                ans += f(n, rest - 1, i + move[k][0], j + move[k][1], dp) / 8;
        }
        dp[rest][i][j] = ans;
        return ans;
    }
};
```

### 题目4：矩阵中和能被K整除的路径
测试链接：https://leetcode.cn/problems/paths-in-matrix-whose-sum-is-divisible-by-k/
1. 暴力递归 -> 记忆化搜索
```c++
class Solution {
private:
    static const int mod = 1000000007;
    int m, n;
public:
    int numberOfPaths(vector<vector<int>>& grid, int k) {
        m = grid.size();
        n = grid[0].size();
        vector<vector<vector<int>>> dp(m, vector<vector<int>>(n, vector<int>(k, -1))); 
        return f(grid, k, 0, 0, 0, dp);
    }   
    //(i, j)到(m - 1, n - 1)有几条对k取余结果为r的路径
    int f(vector<vector<int>>& grid, int k, int i, int j, int r, vector<vector<vector<int>>> &dp){
        if(i == m - 1 && j == n - 1)
            return grid[i][j] % k == r ? 1 : 0;
        if(dp[i][j][r] != -1)
            return dp[i][j][r];
        //cur是grid[i][j]，next是剩下的路径需要的余数
        //cur % k = t          -> cur = k * x1 + t
        //(cur + next) % k = r -> cur + next = k * x2 + r
        //next = (r - t + k) % k <- 同余原理 
        int next = (r - (grid[i][j] % k) + k) % k;  
        int ans = 0;
        if(i < m - 1)
            ans = f(grid, k, i + 1, j, next, dp);
        if(j < n - 1)
            ans = (ans + f(grid, k, i, j + 1, next, dp)) % mod;
        dp[i][j][r] = ans;
        return ans;
    } 
};
```
2. 严格位置依赖的动态规划
```c++
class Solution {
private:
    static const int mod = 1000000007;
public:
    //看成压缩的的二维网格
    int numberOfPaths(vector<vector<int>>& grid, int k) {
        int m = grid.size();
        int n = grid[0].size();
        vector<vector<vector<int>>> dp(m, vector<vector<int>>(n, vector<int>(k, 0)));
        dp[m - 1][n - 1][grid[m - 1][n - 1] % k] = 1;
        for(int i = m - 2; i >= 0; i--){
            for(int r = 0; r < k; r++)
                dp[i][n - 1][r] = dp[i + 1][n - 1][(r - (grid[i][n - 1] % k) + k) % k];
        }
        for(int j = n - 2; j >= 0; j--){
            for(int r = 0; r < k; r++){
                dp[m - 1][j][r] = dp[m - 1][j + 1][(r - (grid[m - 1][j] % k) + k) % k];
            }
        }
        for(int i = m - 2; i >= 0; i--){
            for(int j = n - 2; j >= 0; j--){
                for(int r = 0; r < k; r++){
                    int next = (r - (grid[i][j] % k) + k) % k;  
                    dp[i][j][r] = (dp[i + 1][j][next] + dp[i][j + 1][next]) % mod;
                }
            }
        }
        return dp[0][0][0];
    }   
};
```

### 题目5：扰乱字符串
测试链接：https://leetcode.cn/problems/scramble-string/
1. 暴力递归
```c++
class Solution {
public:
    bool isScramble(string s1, string s2) {
        int n = s1.size();
        vector<vector<vector<int>>> dp(n, vector<vector<int>>(n, vector<int>(n + 1, -1)));
        return f(s1, s2, 0, 0, n, dp);
    }
    //s2[l2开始len长度]是否是s1[l1开始len长度]的扰乱字符串
    bool f(const string &s1, const string &s2, int l1, int l2, int len, vector<vector<vector<int>>> dp){
        if(len == 1)
            return s1[l1] == s2[l2];
        if(dp[l1][l2][len] != -1)
            return dp[l1][l2][len];
        bool ans = false;
        for(int leftLen = 1; leftLen < len; leftLen++){
            int rightLen = len - leftLen;
            //情况一：不交换左右两个子字符串
            if(f(s1, s2, l1, l2, leftLen, dp) && f(s1, s2, l1 + leftLen, l2 + leftLen, rightLen, dp)){
                ans = true;
                break;
            }
            //情况二：交换左右两个子字符串，右边的串是不动的，左边的串交换下位置就行
            if(f(s1, s2, l1 + leftLen, l2, rightLen, dp) && f(s1, s2, l1, l2 + rightLen, leftLen, dp)){
                ans = true;
                break;
            }
        }
        dp[l1][l2][len] = ans ? 1 : 0;
        return ans;    
    }
};
```
2. 记忆化搜索
```c++
class Solution {
public:
    bool isScramble(string s1, string s2) {
        int n = s1.size();
        vector<vector<vector<int>>> dp(n, vector<vector<int>>(n, vector<int>(n + 1, -1)));
        return f(s1, s2, 0, 0, n, dp);
    }
    //s2[l2开始len长度]是否是s1[l1开始len长度]的扰乱字符串
    bool f(const string &s1, const string &s2, int l1, int l2, int len, vector<vector<vector<int>>> &dp){
        if(len == 1)
            return s1[l1] == s2[l2];
        if(dp[l1][l2][len] != -1)
            return dp[l1][l2][len];
        bool ans = false;
        for(int leftLen = 1; leftLen < len; leftLen++){
            int rightLen = len - leftLen;
            //情况一：不交换左右两个子字符串
            if(f(s1, s2, l1, l2, leftLen, dp) && f(s1, s2, l1 + leftLen, l2 + leftLen, rightLen, dp)){
                ans = true;
                break;
            }
            //情况二：交换左右两个子字符串，右边的串是不动的，左边的串交换下位置就行
            if(f(s1, s2, l1 + leftLen, l2, rightLen, dp) && f(s1, s2, l1, l2 + rightLen, leftLen, dp)){
                ans = true;
                break;
            }
        }
        dp[l1][l2][len] = ans ? 1 : 0;
        return ans;    
    }
};
```
3. 严格位置依赖的动态规划（大的长度依赖小的长度）
```c++
class Solution {
public:
    bool isScramble(string s1, string s2) {
        int n = s1.size();
        vector<vector<vector<bool>>> dp(n, vector<vector<bool>>(n, vector<bool>(n + 1, false)));
        for(int l1 = 0; l1 < n; l1++){
            for(int l2 = 0; l2 < n; l2++)
                dp[l1][l2][1] = s1[l1] == s2[l2];
        }
        for(int len = 2; len <= n; len++){  
            for(int l1 = 0; l1 <= n - len; l1++){
                for(int l2 = 0; l2 <= n - len; l2++){
                    for(int leftLen = 1; leftLen < len; leftLen++){
                        int rightLen = len - leftLen;
                        //情况一：不交换左右两个子字符串
                        if(dp[l1][l2][leftLen] && dp[l1 + leftLen][l2 + leftLen][rightLen]){
                            dp[l1][l2][len] = true;
                            break;
                        }
                        //情况二：交换左右两个子字符串，右边的串是不动的，左边的串交换下位置就行
                        if(dp[l1 + leftLen][l2][rightLen] && dp[l1][l2 + rightLen][leftLen]){
                            dp[l1][l2][len] = true;
                            break;
                        }
                    }
                }
            }
        }
        return dp[0][0][n];
    }
};
```
